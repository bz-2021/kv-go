事务的基本概念： 事务是一组原子性的操作，要么全部成功，要么全部失败。

标准的事务定义有四个属性

原子性：事务的不可分割性，事务中的所有操作要么全部成功，要么全部失败回滚。

一致性：事务执行前后，数据的完整性约束没有被破坏。

隔离性：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务是不可见的。

持久性：事务一旦提交，对数据的修改是永久性的。

如何保证原子写？

一般通过预写日志来实现 在MySQL中，使用到了undo log来保存事务回滚的信息
，当事务提交失败后，会利用undo log来将数据恢复到事务开始之前的状态

如何实现隔离性：

隔离性是ACID四个属性当中最难实现的，隔离性的定义的标准几个隔离级别如下：

- 读未提交（存在的问题：脏读）
- 读已提交（存在的问题：不可重复读）
- 可重复读（存在的问题：幻读）
- 串行化


并发控制的实现

隔离性主要控制多个并发执行事务的正确性，避免由于事务交叉执行导致数据不一致

**两阶段锁**

在事务的执行过程当中，对需要操作的对象加锁，如果其他事务与需要操作同一个对象时，也会等待另一个事务释放锁，或者直接因为未获取到锁而回滚，避免发生死锁

**MVCC**

在修改一条数据时，我们并不修改其原有的数据，而是增加一条新的数据，并标识其版本，这样可以实现读写事务之间互不阻塞，因为它们都在执行的过程中维护了自己的数据版本

基于MVCC实现的事务隔离方式，一般叫做快照隔离，简称SI，并不是标准定义中的事务的四种隔离级别，它的基本思路是每个事务都持有一个自己的快照，事务读数据的时候会基于事务开始时的一个快照，其他事务的修改不会对读取有影响，当事务提交后，它的修改才会被其他的事务看到。

SI基本解决了脏读、不可重复读、幻读的问题、但是仍然存在写偏斜（Write Skew）的问题

后面又有人提出了串行化快照隔离（Serializable Snapshot Isolation）

SI只会检测写写冲突，而SSI则会对读取过的数据进行跟踪，并且在提交时进行冲突检测

SSI的大概思路：

写数据

- 将数据暂存到内存中，并记录每个key到一个集合中，便于冲突检测
- 提交事务
  - 加锁保证线程安全
  - 检测冲突，当前事务读取过的key是否被其他的事务修改过，如果是，则说明有冲突，事务放弃提交，回滚。
  - 获取当前最新的事务序列号，一般书全局递增，每个事务都分配了一个序列号
  - 将所有需要写入的数据，key进行编码，加上事务序列号
  - 将数据批量写到存储引擎，保证原子性和持久性
  - 写完后更新内存索引

读数据

- 从当前事务的数据集合中获取，如果获取到直接返回
- 未获取到，则key+当前事务序列号，从存储引擎中读取数据，然后返回
- 将读过的数据记录下来，便于在提交事务时进行冲突检测